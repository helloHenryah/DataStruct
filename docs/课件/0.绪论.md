# 绪论

## 为什么要学数据结构？

- 数据结构是计算机科学的重要基础课程之一
- 数据结构是计算机考研必考科目
  - 全国计算机统考标准408包括：数据结构、计算机组成原理、计算机网络、操作系统
  - 工大计算机考研标准808只考数据结构
- 数据结构是算法竞赛考察的进阶内容

## 数据结构是什么？

**程序 = 数据结构 + 算法。**

**数据结构 = 数据 + 结构。**

完全无法理解这个答案？没有关系。
本门课程将由这两个公式开始，也由这个两个公式结束。
你所需要做的是带着对这个问题疑问，在后面的章节不断探索，最终理解这一概念。

解释抽象概念有两种方法，一种是高度凝练，另一种是巨细无遗。
我们在绪论中首先给出前者，在绪论外的章节实践后者。

## 算法分析

**程序 = 数据结构 + 算法。**
数据结构和算法是密不可分的，在研究这两者时有是先设计出了数据结构再找到了它的算法应用，有时是先设计了算法再为算法寻找需要的数据结构。
因此在学习数据结构的时候，我们不能把它剥离出来单独理解，而是必须配合着算法一同学习。
而从算法分析入手就是一个较好的选择。

### 算法复杂度

评级一个人可以从多个角度入手，他的成就，个人事迹，他人对他的评价等等。
评价一个算法同样如此，而其中一个最重要的角度是算法复杂度。
算法复杂度包括时间复杂度和空间复杂度，这两者绝大多数情况下是鱼与熊掌的关系。
所谓算法分析也就是去思考什么时候该吃鱼，什么时候该吃熊掌。

#### 时间复杂度

算法用时随数据规模而增长的趋势，即**时间复杂度**。

##### 大 $O$ 表示法

![Big-O](images/Big-O.png)

假设算法的问题规模为n，那么输入的数据规模可以用函数 $f(n)$ 来表示。

随着数据规模n的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 $O(f(n))$。

算法导论给出的解释：大 $O$ 用来表示上界的，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

>此小节侧重实用性，不作严谨的说明。
>详细内容可参考[OI-Wiki](https://oi-wiki.org/basic/complexity/)上的讲解

##### 常数级

$O(n)=1$
- 输出
```c
void f(int a)
{
  printf("%d",a);
}
```

##### 线性级

$O(n)=n$
- 简单循环
```c
//a[]是简单输出数组，len是数组长度
void f(int a[],int len)
{
  for(inti=0;i<len;i++)
  printf("%d ",a[i]);
}
```


  
##### 对数级
$O(n)=log(n)$
- 快速排序
- 折半查找（对于某个升序数列查找数据的位置）
```c
//key是查找量,a是查找的数列，len是数组a的长度
void f(int key,int a[],int len)
 {
 	int i,high,low,mid;
 	int count1=0,count=0;
 	low=0;
 	high=len-1;
 	while(high>=low) 
 	{	
		count++;
		mid=(high+low)/2;
 		if(key<a[mid])
		high=mid-1;
 		else if(key>a[mid])
 		low=mid+1;
		if(key==a[mid])
		{
			printf("%d",mid);
			count1++;
			break;
		}
	}
	 if(count1==0)
	 printf("不存在");
 }
```


##### 幂级
$O(n)=2^n$
- 冒泡排序
```c
//a[]是排序数组，len是数组长度
void f(int a[],int len)
{
  for(int i=0;i<len-1;i++)
    for(int j=0;j<len-1;j++)
    if(a[j]>a[j+1])
    {
      int t=a[j];
      a[j]=a[j+1];
      a[j+1]=t;
    }
    for(int i=0;i<len;i++)
    printf("%d ",a[i]);
}
```
- 选择排序

```c
//a[]是排序数组，len是数组长度v
void f(int a[],int len)
{
  for(i=0;i<len;i++)
    {
      pos=i;
      for(k=i+1;k<len;k++)
      {
          if(a[k]<a[pos])
          {
            pos=k;
          }
        }
      if(pos!=i)
      {
        int c;
        c=a[i];
        a[i]=a[pos];
        a[pos]=c;
      }
    }
    for(i=0;i<len;i++)
    {
        printf("%d ",a[i]);
    }    
}
```
  
##### 指数级
$O(n)=2^n$
- 递归求解斐波那契数列
```c
int f(int n)
{
  if(n==0)
  return 0;
  else if(n==1)
  return 1;
  else 
  return f(n-1)+f(n-2);
}
```

##### 阶乘级别
$O(n)=n!$
- 暴力算法
- 注意：一般不推荐此类算法

#### 空间复杂度

- 桶排序
```c
//a[]是排序数组，len是数组长度
#define N 100
void f(int a[],int len)
{
  int tong[N]={0};
  for(int i=0;i<len;i++)
  {
    tong[a[i]]++;
  }
  for(int i=0;i<N;i++)
  while(tong[i]>0)
  {
  printf("%d ",i);
  tong[i]--;
  }
}

```
### 算法优化



## 算法思想

### 有哪些算法思想？

枚举/朴素/暴力、模拟、分治和递归、贪心、动态规划、回溯、排序、查找、搜索

### 算法思想与现实生活的联系

## 算法中的数据结构
